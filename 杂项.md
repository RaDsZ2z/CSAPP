<a href="#1.">1.大小端序 和 堆栈内存增长方向</a>

<a href="#2.">2.关于寄存器</a>

<a href="#3.">3.关于汇编版本</a>

<a href="#4.">4.地址与立即数 寄存器与间接寻址</a>

<a href="#5.">5.寄存器rbp/ebp的作用</a>

<a href="#6.">6.gdb用函数名打断点</a>

# <div id="1."> 1.大小端序 和 堆栈内存增长方向</div>
小端序：低位字节存储在较小内存地址处

大端序：低位字节存储在较大内存地址处


堆：生长方向是向上的，也就是向着内存地址增大的方向

栈：生长方向是向下的，也就是向着内存地址减小的方向
# <div id="2."> 2.关于寄存器 </div>
传参：
![2250390cadb071f5a8c69b05d5b656c8](https://github.com/RaDsZ2z/CSAPP/assets/129292565/aff79779-3ca3-4747-877d-b60386390463)
传参与返回值：
![f6b8761292346c79bc0c32c6658050b5](https://github.com/RaDsZ2z/CSAPP/assets/129292565/61ab79ce-f671-4874-82bb-3fd71fc1a02e)

# <div id="3."> 3.关于汇编版本与差异 </div>
上下两段汇编代码可以看出mov的参数顺序相反

具体地，对于mov a,b在本书中作用是b = a 而在intel x86汇编中作用就是a = b

其它差异见下图
![dec3455c525e3997fd8f71a853c9b3c5](https://github.com/RaDsZ2z/CSAPP/assets/129292565/ca36816d-f025-4288-83f4-a20973cc4ae5)

# <div id="4."> 4.地址与立即数 寄存器与间接寻址</div>
## 4.1.地址与立即数
```
mov    0x804d100,%eax
cmp    0x804d108,%eax
```
这两句的含义为 把内存地址0x804d110处的值存入%eax寄存器，然后将内存地址0x804d108处的值与%eax寄存器中的值进行比较

为什么是内存地址处的值，而不是值呢？因为立即数前面要加$符号，如下。
```
mov    $0x804d100,%eax
cmp    $0x804d108,%eax
```
这两句的含义就是把值0x804d110存入%eax寄存器，然后把值0x804d108与%eax寄存器中的值进行比较
## 4.2.寄存器与间接寻址
4.1.被我忘记了，寄存器与间接寻址此时我是记得的，但是比较类似就一起写一下
```cpp
mov %0x0804d100,%rax  //显然这是存入立即数
mov %0x0804d108,%rbx  //存入立即数
add %rax,%rbx         //%rbx += %rax
add (%rax),%rbx       //%rbx += (0x804d110) 将内存地址0x804d110处的值加到寄存器%rbx中
```
# <div id="5.">5.寄存器rbp/ebp的作用</div>
帧指针

刚刚进入函数时会有
```
push %ebp
mov  %esp,%ebp
```
这样%ebp记录了此函数栈底的位置

在同一函数内,%ebp寄存器的值是保持不变的

函数末尾会有
```
leave
等效于
mov %ebp, %esp
pop %ebp
```
这样函数退出以后%esp和%ebp的值就变为了刚进入函数时一句指令都没有执行时的值

是很方便的“回溯”
# <div id="6.">6.gdb用函数名打断点</div>
假设有如下汇编代码
```
080491f4 <getbuf>:
 80491f4:	55                   	push   %ebp
 80491f5:	89 e5                	mov    %esp,%ebp
 80491f7:	83 ec 38             	sub    $0x38,%esp
 80491fa:	8d 45 d8             	lea    -0x28(%ebp),%eax
 80491fd:	89 04 24             	mov    %eax,(%esp)
 8049200:	e8 f5 fa ff ff       	call   8048cfa <Gets>
 8049205:	b8 01 00 00 00       	mov    $0x1,%eax
 804920a:	c9                   	leave  
 804920b:	c3                   	ret    
```
我在gdb中使用如下指令
```shell
b getbuf
```
断点被打在了0x80491fa的位置，而不是函数开头

据群友所说，开头保存寄存器和申请栈空间的操作不属于函数的实际内容

我想记录的重点是**b 函数名**这个操作，断点往往不会打在“函数的开头”
